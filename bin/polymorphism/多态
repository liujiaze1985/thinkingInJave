在面向对象的程序设计语言中,多态是继数据抽象和继承之后的第三种基本特征
	多态(也称作动态绑定,后期绑定或运行时绑定)
	多态通过分享做什么和怎么做,从另一角度将接口和实现分离开来: 改善代码的组织结构和可读性,还能够创建可扩展的程序
	
	"封装" 通过合并特征和行为来创建新的数据类型."实现隐藏"则通过将细节"私有化"把接口和实现分享开来.
	多态 消除类型之间的耦合关系
	向上转型
		对象既可作为它自己本身的类型使用,也可以作为它的基类型使用.而这种把对某个对象的引用视为对其基类的引用的做法被称作作向上转型
		忘记对象类型
			不管导出类的存在,只与基类打交道
	转机
		方法接受一个基类的引用,在这种情况下,编译器如何知道这个基类引用指向的是哪个导出类对象呢?	
		方法调用绑定(编译器如何知道基类引用指向的是哪个导出类对象)
			将一个方法调用同一个方法主休关联起来被称作绑定
				前期绑定:(面向过程语言的默认的绑定方式,C只有前期绑定)程序执行前进行绑定(如果有的话,由编译器和连接程序实现)
				后期绑定:(动态绑定,运行时绑定)运行时根据对象的类型进行绑定, Java中除了static和final(包含private方法)方法之外,其他所有的方法都是后期绑定,
					这意味通常情况下,我们不必判定是否应该进行后期绑定-它会自动发生.
		产生正确的行为
			在编译时,编译器不需要获得任何特殊信息就能进行正确的调用
		可扩展性
			从通用的基类继承出新的数据类型,从而新添一些功能,那些操纵基类接口的方法不需要任何发动就可以应用于新类
		缺陷:"覆盖"私有方法
			基类的私有方法在子类中是不可见的,不能被覆盖和重载,只有非private方法才可被覆盖,在导出类中,对于基类中的private方法,最好彩不同的名字
		缺陷:域与静态方法
			只有普通的方法调用可以是多态的,
			任何域访问操作都将编译器解析,因此不是多态的
	构造器和多态
		构造器不具有多态性(它们实际上是static方法),需要理解构造器怎样通过多态在复杂的层次结构中动作
		
		构造器的调用顺序
			基类的构造器总是在导出类的构造过程中被调用,而且按照继承层次逐渐向上链接,以使每个基类的构造器𨝌能得到调用
			构造器的作用(检查对象是否被正确地构造):导出类只能访问它自己的成员,不能访问基类中的成员(基类成员通常是private类型),只有基类的构造器才具有恰当的知识和权限来对自己的元素进行初始化,
			因此,必须令所有构造器都得到调用,否则就不可能正确构造完整对象.
			导出类的构造器主体中,如果没有明确指定调用某个基类构造器,它就会"默默"地调用默认构造器,如果不存在默认构造器,编译器就会报错
			构造器的调用顺序
				调用基类构造器
				按声明顺序调用成员的初始化方法
				调用导出类构造器的主体
		继承和清理
			通过组合和继承方法来创建新类时,永远不必担心对象的清理问题,子对象通常都会留给垃圾回收器进行处理.
			导出类覆盖了基类的清理方法,在导出类做清理动作时,必须要调用基类的清理方法,否则,基类的清理动作就不会发生
			销毁的顺序与初始化顺序相反
			
			导出类创建了自己的成员对象,若成员对象中存在于一个或多个对象共享的情况,必需使用引用计数来跟踪仍旧访问着共享对象的对象数量了.(ReferenceCounting.java)
			
		构造器内部的多态方法的行为
			在一个构造器的内部调用下在构造的对象的某个动态绑定方法,会发生什么?
			初始化的实际过程:
				1.在其他任何事物发生之前,将分配给对象的存储空间初始化成二进制的零
				2.调用基类构造器,
				3.按照声明的顺序调用成员的初始化方法
				4.调用导出类的构造器主体
	协变返回类型
		java SE5 中 添加 了协变返回类型,它表示 在导出 类中的被覆盖方法可以返回基类方法的返回类型的某种导出类型
		
	用继承进行设计
		优先选用组合,组合不会强制我们的程序说干就干进入继承的层次结构中.而且,组合更加灵活,因为它可以动态选择类型;相反继承在编译时就需要知道确切类型.
		引用在运行时可以与另一个不同的对象重新绑定起来,所以对象的引用可以被替代,不能在运行期间决定继承不同的对象,因为它要求在编译期间完全确定下来
	 	用继承表达行为间的差异,并用字段表达状态上的变化
	 	
	 	纯继承与扩展
	 		导出类与基类具有一样的接口,这种关系被称作纯粹的"is-a"(是一种)关系
	 		导出类拥有自身的接口,这称为"is-like-a"(像一个)关系,导出类中接口的扩展部分不能被基类访问,向上转型就不能调用那些新方法
 		向下转型与运行时类型识别
 			不安全,有可能贸然转型到一种错误类型,进而发出该对象无法接受的消息
 			RTTI 运行时类型识别,其内容不公公包括转型处理,它还提供一种方法,在试图向下转型之前,查看所要处理的类型.
 			
 			
	总结:
			
			
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		