接口和内部类为我们提供了一种将接口与实现分享的更加结构化的方法
	抽象类是普通类与接口之间的一种中庸之道,在构建具有某些未实现方法的类时,抽象类仍旧是用于此目的的一种重要而必须的工具,因为不可能总是使用纯接口


抽象类和抽象方法
	抽象类(抽象基类)的目的是为它的所有导出类创建一个通用接口,创建抽象类是希望通过这个通用接口操纵一系列类
	抽象方法: 仅有声明而没有方法体,相当于C++语言中的纯虚函数
	抽象类和抽象方法可以使类的抽象性明确起来,抽象类还是很有用的重构工具
		abstract void f();
		抽象类
			包含抽象方法的类叫做抽象类,如果一个类包含一个或多个抽象方法,该类必须被限定为抽象的(否则,编译器就会报错)
			没有任何抽象方法的抽象类: 如果一个类,让其包含任何abstract方法都显得没有实际意义,而且我们也想要阻止产生这个类的任何对象,那么这样做就很有用
		抽象方法
			
接口
	abstract 允许在类中创建一个或多个没有任何定义的方法---提供了接口部分,但是没有提供任何相应的具体实现,这些实现是由此类的继承者创建的.
	interface  产生一个完全抽象的类,它允许创建者确定方法名,参数列表和返回类型,但是没有任何方法体
	一个接口表示: "所有实现了该特定接口的类看起来都像这样",接口被用来建立类与类宰的协议(某些面向对象编程语言使用关键字protocol来完成这一功能)
	接口也可以包含域,但是这些域隐式地是static和final的
	接口中的方法是public的,当要实现一个接口时,在接口中被定义的方法必须被定义为是public的;否则,它们将只能得到默认的包访问权限,这样在方法被继承的过程中,其可访问权限就被降低了,这是java编译器所不允许的

完全解耦
	策略设计模式: 创建一个能够根据所传递的参数对象的不同而具有不同行为的方法,其包含所要执行的算法中固定不变的部分,而策略就是传递进去的参数对象,其包含变化的部分
	适配器设计模式:适配器中的代码将接受你拥有的接口,并产生你所需要的接口
	将接口从具体实现中解耦使用接口可以应用于多种不同的具体实现,因此代码也就更具可利用性
	
Java的多重继承
	C++中,组合多个类的接口的行为被称作是多重继承,有时用来表示"一个x是一个a和一个b以及一个c"
	从一个非接口的类继承,那么只能从一个类去继承,其余的基元素都必须是接口,需要将所有的接口名都置于implements关键字之后,用逗号将它们一一隔开,可以继承任意多个接口,并可以向上转型为每个接口,因为每一个接口都是一个独立类型
	该例所展示的就是使用接口的核心原因:
		1.为了能够向上转转型为多个基类型(以及由此而带来的灵活性)
		2.与抽象基类相同,防止客户端程序员创建该类的对象,并确保这仅仅是建立一个接口
	如何选择使用接口还是抽象类?
		如果要创建不带任何方法定义和成员变量的基类,那么就应该选择接口而不是抽象类.(事实上,如果知道某事物应该成为一个基类,那么第一选择应该是使它成为一个接口)
		
通过继承来扩展接口
	

适配接口
接口中的域
嵌套接口
接口与工厂
总结