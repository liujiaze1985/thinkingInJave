复用代码:
1.在新的类中产生现有类的对象.(由于新的类是由现有类的对象所组成,所以这种方法称为组合,该方法只是复用了现有程序代码的功能,而非它的形式)
2.按照现有类的类型来创建新类(无需改变现有类的形式,采用现有类的形式并在其中添加新代码 (继承))

组合语法:
	只需将对象引用置于新类中即可
继承语法:
	继承过程中,需要先声明"新类与旧类相似" extends,继承会自动得到基类中所有的域和方法
	
	初始化基类
		导出类所产生的结果对象,从外部来看,它就像是一个与基类具有相同接口的新类,或许还会有一些额外的方法和域.
		当创建了一个导出类的对象时,该对象包含了一个基类的子对象,这个子对象与你用基类直接创建的对象是一样的.二者区别在于,后者来着自于外部,而基类的子对象被包装在导出类对象内部
		对基类子对象的正确初始化,在构造器中调用基类构造器来执行初始化,而基类构造器具有执行基类初始化所需要的所有知识和能力,java会自动在导出类的构造器中插入对基类构造器的调用
		* 构建过程是从基类"向外"扩散的,所以革类在导出类构造器可以访问它之前,就已经完成了初始化.
		
		带参数的构造器
			如果没有默认的基类构造器,或者想调用一个带参数的基类构造器,就必须用关键字super显式地编写调用基类构造器的语句,并且配以适当的参数列表
			
代理:
	Java没有提供对它的直接支持,这是继承与组合之间的中庸之道,因为我们将一个成员对象置于所要构造的类中(就像组合),但与些同时我们在新类中暴露了该成员对象的所有方法(就像继承)
	
结合使用组合和继承:
	虽然编译器强制初始化基类,并且要求在构造器起始处就要这么做,但是它并不监督将成员对象也初始化,

	确保正确清理:
		想要某个类清理一些东西,就必须显式地编写一个特殊的方法来做这件事,必需将这一清理动作置于finally子句之中,以预防异常的出现
		清理时与初始化基类顺序相反,先导出类,再基类
		*除了内存以外,不能信赖垃圾回收器去做任何事,如果需要进行清理,最好是编写自己的清理方法,但不要使用finalize()
	
	名称屏蔽
	
	CompileTimeError : 
		@Override 在不想重载时而意外地进行了重载编译器会报以下错误 
		method does not override a method from its superclass
	
在组合与继承之间选择 :
	组合和继承都允许在新的类中放置子对象,组合是显式地,而继承是隐式地.
	1.组合技术通常用于想在新类中使用现有类的功能而非它的接口这种情形(即在新类中嵌入某个对象,让其实现所需要的功能,但新类的用户看到的只是为新类所定义的接口,
		而非所嵌入对象的接口.为取得此效果,需要在新类中嵌入一个瑞有类的private对象)
		将成员对象声明为public,允许类的用户直接访问新类中的组合成分
	2.在继承的时候使用某个现有类,并开发一个它的特殊版本.(通常这意味着你在使用一个通用类,并为了某种特殊需要而将其特殊化
		例:用交通工具对象来构成一部车子是毫无意义的,因为"车子"并不包含"交通工具",它仅是一种交通工具(is-a关系)
		is-a(是一个)的关系是用继承来表达的,而"has-a"的关系则是用组合来表达的)
	3.到底该用组合还是继承,一个最清晰的判断办法就是问自己是否需要从新类向基类进行向上转型,如果必须向上转型,则继承是必要的,但如果不需要,则应当好好考虑自己是否需要继承

protected关键字
	protected的作用,就类用户而言这是private的,但对于任何继承于此类的导出类或其他任何位于同一个包内的类来说,它却是可以访问的(protected也提供了包内访问权限)
	最好的方式还是将域保持为private ,应当保留"更改底层实现"的权利,然后通过protected方法来控制类的继承者的访问权限

向上转型
	继承:新类和基类之间的关系,可以用新类是现有类的一种类型
	将导出类引用转换为基类引用的动作,称之为向上转型
	在向上转型的过程中,类接口中唯一可能发生的事情是丢失方法,而不是获取它们,这就是为什么编译器在"未曾明确表示转型"或"未曾指定特殊标记"的情况下,仍然允许向上转型的原因
	
final关键字
	使用final的三种情况: 数据,方法,类
		数据: 
			1.一个永不改变的编译时常量(对基本类型,使数值恒定不变;而对于对象引用,使引用恒定不变)
			2.一个在运行时被初始化的值,而你不希望它被改变
			
			将final数值定义为静态和非静态的区别是: 此区别只有当数值在运行时内被初始化时才会显现,这是因为编译器对编译数据一视同仁(并且它们可能因优化而消失),当程序运行时可看到该区别
			空白final
				是指被声明为final但又未给定初值的域. 无论什么情况,编译器都确保空白final在使用前必须被初始化.
				但是空白final在关键字final的使用上提供了更大的灵活性,为此,一个类中的final域就可以做到根据对象而有所不同,却又保持其恒定不变的特性
				(必须在域的定义处勤劳每个构造器中用表达式对final进行赋值,这正是final域在使用前总是被初始化的原因所在)
			参数:
				在参数列表中以声明的方式将参数指明为final,意味着你无法在方法中更改参数引用所指向的对象,只可读,主要用来向匿名内部类传递数据
		
		方法:
			使用final方法的两个原因:
				1.锁定方法,以防任何继承类修改它的含义
				2.效率:早期如果将一个方法指明为final,就是同意编译器将针对该方法的所有调用都转为内嵌调用.(这种方法现在不推荐使用,只有在想要明确禁止覆盖时,才将方法设置成final)
					运行机制:编译器发现一个final方法调用命令时,它会根据自己的谨慎判断,跳过插入程序代码这种正常方式而执行方法调用机制(将参数压入栈,跳至方法代码处并执行,然后跳回并清理栈中的参数,处理返回值)
					,并且以方法休中的实际代码的副本来替代方法调用,这将消除方法调用的开销. 当然,如果一个方法很大,你的程序代码就会膨胀,因而可能看不到内嵌带来的任何性能提高,因为,所带来的性能提高会因为花
					费于方法内的时间量而被缩减
				* 覆盖 只有在某方法是基类的接口的一部分时才会出现(即,必须能将一个对象向上转型为它的基本类型并调用相同的方法),如果是private,它就不是基类的接口的一部分,
				如果在导出类中以相同的名称生成一个public,protected或包访问权限方法的话,此时你并没有覆盖该方法,公是生成了一个新的方法
		类:
			将某个类的整体定义为final时(),表明你不打算继承该类
			
		忠告:设计类时,将方法指明是final,应该说是明智的
			缺点:可能会妨碍其他程序员在项目中通过继承来利用该类, 如Vector,HashTable

初始化及类的加载
	java每个类的编译代码都存在于它自己的独立的文件中,该文件只在需要使用程序代码时才会被加载.通常是指加载发生于创建类的第一个对象之时,但是当访问static域或static方法时,也会发生加载
	初次使用之处也是static初始化发生之处.所有的static对象和static代码段都会在加载时依程序中的顺序而依次初始化
	
继承与初始化
	
总结:
	继承和组合都能从现有类型生成新类型.组合一般是将现有类型作为新类型底层实现的一部分来加以利用,而继承利用的是接口
	继承时,导出类可向上转型至基类(对多态很重要)
	优先使用组合或代理,必要时才使用继承
			