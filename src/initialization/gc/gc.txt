java 垃圾回收器只知道释放那些经由new分配的内存,不知道该如何释放并非使用new获得的特殊内存
针对上述情况,java允许在类中定义一个名为finalize()的方法
finalize()工作原理: 一旦垃圾回收器准备好释放对象战胜的存储空间,将首先调用finalize()方法,并且在下一次垃圾回收动作发生时,才会真正回收对象战胜的内存.
java里的对象却并非总是被垃圾回收.
 1.对象可能不被垃圾回收
 2.垃圾回收并不等于"析构" (C++中析构函数 销毁对象必须用到析构函数)
 3.垃圾回收只与内存有关
 
 非new获得特殊内存:
      本地方法(目前只支持C和C++)的调用,非java代码中,也许会调用C的malloc()函数来分配存储空间,有且只有调用free()(C和C++中的函数)函数,否则存储空间将得不到释放
      要释放该部分内存,需要在finalize()中用本地方法调用它
 C++中对象都会被销毁,C++有局部对象的(在堆栈上创建,java中没有),销毁动作发生在以"右花括号"为边界的,此对象作用域的末尾处.如果对象是用new创建的,当C++调用delete操作符(java中无该操作符),时就会调用相应的析构函数
 如忘记调用delete,会造成内存泄露
 java中垃圾回收器的存在并不能完全代替析构函数,如果希望进行除释放存储空间之外的清理工作,还是得明确调用某个恰当的java方法,这就等同于使用析构函数
 finalize()并不信赖于每次都要对其进行调用: 当对某个对象不再感兴趣(可清理),这个对象应该处于某种状态,使它占用的内存可以被安全的释放.
 
 
垃圾回收器如何工作
java从堆分配空间的速度非常高
其它系统垃圾回收机制:
 引用记数:每个对象都含有一个引用户数器,当有引用连接至对象时,引用计数加1,当引用离开作用域或被置为null时,引用计数减1. 垃圾回收器会在含有全部对象的列表上遍历,当发现某个对象象的引用计数为0时,就释放其占用的空间
 其它方法思路:对任何"活"的对象,一定能最终追溯到其存活在堆栈或静态存储区之中的引用
 	停止-复制(非后台):暂停程序,从所有存活对象从当前堆复制到另一个堆(目标堆中,对象是一个挨一个的),没有被复制的全部都是垃圾
 	标记-清扫(非后台):从堆栈和静态存储区出发,遍历所有引用,进而找出所有存活的对象,找到一个标记一个,此过程不回收任何对象,只有全部标记完成,才开始清理
 自适应的垃圾回收技术:
	 内存分配以块为单位,如果对象较大,它会单独占用块.有了块之后可以往废弃的块里拷贝对象. 每个块都用相应的代数来记录它是否还存活.
	 	垃圾回收器会定期进行完整的清理动作: 大型对象仍不会被复制(只是其代数会增加),内含小型对象的那些块则被复制并整理.
	 Java虚拟机会进行监视,如果所有对象都很稳定,垃圾回收器的效率降低的话,就切换到标记-清扫方式;同样Java虚拟机会跟踪"标记-清扫"的效果,要是堆空间出现很多碎片,就会切换回"停止-复制"方式,这就是自适应技术
	 
 	
 	